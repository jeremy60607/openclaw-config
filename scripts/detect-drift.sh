#!/usr/bin/env bash
set -euo pipefail

# ===========================================
# OpenClaw Drift Detection
# Compares live config vs template,
# outputs JSON diff report.
# Exit 0 = no drift, Exit 1 = drift detected.
# ===========================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"
OPENCLAW_HOME="$HOME/.openclaw"
LIVE_CONFIG="$OPENCLAW_HOME/openclaw.json"
TEMPLATE="$PROJECT_DIR/openclaw.template.json"
SKILLS_DIR="$OPENCLAW_HOME/skills"
SKILLS_LIST="$PROJECT_DIR/skills/skills-list.md"

# --- Pre-flight ---
if [ ! -f "$LIVE_CONFIG" ]; then
  echo '{"error": "Live config not found"}' >&2
  exit 2
fi

if [ ! -f "$TEMPLATE" ]; then
  echo '{"error": "Template not found"}' >&2
  exit 2
fi

if ! command -v node &>/dev/null; then
  echo '{"error": "Node.js required"}' >&2
  exit 2
fi

# --- Detect drift (node outputs JSON to stdout) ---
set +e
DRIFT_JSON=$(node -e "
const fs = require('fs');

const live = JSON.parse(fs.readFileSync('$LIVE_CONFIG', 'utf8'));
const template = JSON.parse(fs.readFileSync('$TEMPLATE', 'utf8'));

// Sanitize live config (same logic as sync.sh)
const sanitized = JSON.parse(JSON.stringify(live));

if (sanitized.gateway?.auth?.token) {
  delete sanitized.gateway.auth.token;
  sanitized.gateway.auth._token_comment = 'Token is auto-generated by onboard wizard. Do NOT put real token here.';
}
if (sanitized.channels?.telegram?.botToken) {
  delete sanitized.channels.telegram.botToken;
  sanitized.channels.telegram._botToken_comment = 'Set via OPENCLAW_TELEGRAM_BOT_TOKEN env var or paste during onboard wizard';
}
if (sanitized.auth?.profiles) {
  for (const key of Object.keys(sanitized.auth.profiles)) {
    delete sanitized.auth.profiles[key].apiKey;
    delete sanitized.auth.profiles[key].token;
  }
}
delete sanitized.meta;
delete sanitized.wizard;

// Build comparable object (add schema/comment to sanitized)
const liveNorm = { '\$schema': template['\$schema'] || 'https://docs.openclaw.ai/schema/openclaw.json' };
liveNorm._comment = template._comment || 'OpenClaw config template. Secrets (tokens, API keys) should use env vars, not this file.';
const templateKeys = Object.keys(template).filter(k => k !== '\$schema' && k !== '_comment');
const sanitizedKeys = Object.keys(sanitized).filter(k => k !== '\$schema' && k !== '_comment');
const allKeys = [...new Set([...templateKeys, ...sanitizedKeys])];
for (const key of allKeys) {
  if (sanitized[key] !== undefined) liveNorm[key] = sanitized[key];
}

// Deep compare and collect changes
const configChanges = [];

function findChanges(path, templateObj, liveObj) {
  if (templateObj === undefined && liveObj !== undefined) {
    configChanges.push({ path, type: 'added', value: liveObj });
    return;
  }
  if (templateObj !== undefined && liveObj === undefined) {
    configChanges.push({ path, type: 'removed', oldValue: templateObj });
    return;
  }
  if (typeof templateObj !== typeof liveObj) {
    configChanges.push({ path, type: 'changed', oldValue: templateObj, newValue: liveObj });
    return;
  }
  if (Array.isArray(templateObj) || Array.isArray(liveObj)) {
    if (JSON.stringify(templateObj) !== JSON.stringify(liveObj)) {
      configChanges.push({ path, type: 'changed', oldValue: templateObj, newValue: liveObj });
    }
    return;
  }
  if (typeof templateObj === 'object' && templateObj !== null) {
    const keys = [...new Set([...Object.keys(templateObj), ...Object.keys(liveObj)])];
    for (const key of keys) {
      findChanges(path ? path + '.' + key : key, templateObj[key], liveObj[key]);
    }
    return;
  }
  if (templateObj !== liveObj) {
    configChanges.push({ path, type: 'changed', oldValue: templateObj, newValue: liveObj });
  }
}

findChanges('', template, liveNorm);

// --- Detect skill drift ---
const skillsAdded = [];
const skillsRemoved = [];

let installedSkills = [];
try {
  const entries = fs.readdirSync('$SKILLS_DIR');
  installedSkills = entries.filter(e => !e.startsWith('.'));
} catch (e) {}

let listedSkills = [];
try {
  const content = fs.readFileSync('$SKILLS_LIST', 'utf8');
  // Only match skills installed to ~/.openclaw/skills (table rows containing the skills dir path)
  // This excludes npm global skills (clawhub, mcporter, etc.)
  const matches = content.matchAll(/^\| ([\w][\w.-]*) \|[^|]*\|/gm);
  const skills = new Set();
  for (const m of matches) {
    if (m[1] !== 'Skill') skills.add(m[1]);
  }
  // Filter: only keep skills whose table row references the skills dir
  const lines = content.split('\\n');
  const localSkills = new Set();
  for (const line of lines) {
    const rowMatch = line.match(/^\| ([\w][\w.-]*) \|/);
    if (rowMatch && rowMatch[1] !== 'Skill' && line.includes('.openclaw/skills')) {
      localSkills.add(rowMatch[1]);
    }
  }
  listedSkills = [...localSkills];
} catch (e) {}

for (const skill of installedSkills) {
  if (!listedSkills.includes(skill)) skillsAdded.push(skill);
}
for (const skill of listedSkills) {
  if (!installedSkills.includes(skill)) skillsRemoved.push(skill);
}

// --- Output ---
const hasDrift = configChanges.length > 0 || skillsAdded.length > 0 || skillsRemoved.length > 0;

const report = {
  hasDrift,
  configChanges,
  skillsAdded,
  skillsRemoved,
};

console.log(JSON.stringify(report, null, 2));
" 2>&1)
NODE_EXIT=$?
set -e

if [ $NODE_EXIT -ne 0 ]; then
  echo "ERROR: Failed to generate drift report:" >&2
  echo "$DRIFT_JSON" >&2
  exit 2
fi

# Output the report
echo "$DRIFT_JSON"

# Set exit code based on drift
HAS_DRIFT=$(echo "$DRIFT_JSON" | node -e "process.stdout.write(String(JSON.parse(require('fs').readFileSync('/dev/stdin','utf8')).hasDrift))")

if [ "$HAS_DRIFT" = "true" ]; then
  exit 1
else
  exit 0
fi
